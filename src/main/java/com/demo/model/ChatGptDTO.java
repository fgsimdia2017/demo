package com.demo.model;

import cn.hutool.core.collection.CollectionUtil;
import cn.hutool.core.util.StrUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * @Author huangfeng
 * @Date 2023/11/14 14:53
 * @description
 * @Version 1.0
 */
public class ChatGptDTO {
    public static List<String> splitText2Parts(String text, int maxLength, int maxOffset) {
        if (StrUtil.isBlankIfStr(text)) {
            return Collections.emptyList();
        }
        List<String> parts = new ArrayList<>();
        if (text.length() <= maxLength) {
            return Collections.singletonList(text);
        }
        for (int i = 0; i < text.length(); i++) {
            if (i < maxLength) {
                continue;
            }
            int lastIndex = getLastIndex(parts);
            int startIndex = (i - lastIndex);
            // 最后结尾不管多少条直接结束
            if (i == text.length() - 1) {
                String subResult = text.substring(lastIndex, i + 1);
                parts.add(subResult);
                continue;
            }
            // 其它条件下,不是结尾,必须要有最大条数的情况下才划分
            if (i - lastIndex < maxLength) {
                continue;
            }
            String str = text.substring(i, i + 1);
            // 获取到以.等结尾的直接结束
            if (".".equals(str) || "?".equals(str) || "!".equals(str)) {
                String subResult = text.substring(lastIndex, i + 1);
                parts.add(subResult);
                continue;
            }
            // 超过阈值时,直接以当前index结束
            if (startIndex % maxLength >= maxOffset) {
                String subResult = text.substring(lastIndex, i + 1);
                parts.add(subResult);
            }

        }
        return parts;
    }

    private boolean isCloseSign(String str) {
        if (StrUtil.isBlankIfStr(str)) {
            return false;
        }
        return Arrays.asList("。", "？", "！", "…", ".", "?", "!", ".").contains(str);
    }

    public static int getLastIndex(List<String> parts) {
        if (CollectionUtil.isEmpty(parts)) {
            return 0;
        }
        int index = 0;
        for (String part : parts) {
            index += part.length();
        }
        return index;
    }

    public static void main(String[] args) {
        String text = "<p>By <a href=\"https://twitter.com/ibalajiarun\" target=\"_blank\">Balaji Arun</a> and <a href=\"https://twitter.com/SashaSpiegelman\" target=\"_blank\">Alexander Spiegelman</a></p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/cl0dttkbdwza.png'/</figure><p>World-class engineering meets cutting-edge research at Aptos. For more details, please refer to the <a href=\"https://arxiv.org/pdf/2306.03058.pdf\" target=\"_blank\">Shoal paper</a><strong>.</strong></p><p><strong>TL;DR: We have solved two important open problems in DAG BFT that significantly reduce latency and, for the first time, have eliminated the need for timeouts in deterministic practical protocols. Overall, we have improved Bullshark’s latency by 40% in the failure-free case and by 80% in the failure case.</strong></p><p>Shoal is a framework for enhancing any Narwhal-based consensus protocol (e.g., DAG-Rider, Tusk, Bullshark) with pipelining and leader reputation. Pipelining reduces DAG ordering latency by introducing an anchor every round and, leader reputation further improves it by ensuring anchors are associated with the fastest validators. Moreover, leader reputation allows Shoal to take advantage of the asynchronous DAG construction to eliminate timeouts in all (but extremely uncommon) scenarios. This allows Shoal to provide a property we name Prevalent Responsiveness, which subsumes the often desired Optimistic Responsiveness.</p><p>Our technique, which is surprisingly simple, involves running multiple instances of the underlying protocol one after another sequentially. Consequently, when instantiated with Bullshark, we obtain a Shoal of sharks running a relay race.</p><h3>Motivation</h3><p>In the pursuit of high performance in blockchain networks, there has been a focus on reducing communication complexity. However, this approach has not led to significant improvements in throughput. For instance, Hotstuff — implemented in earlier versions of Diem — achieves only <a href=\"https://arxiv.org/pdf/2103.04234.pdf\" target=\"_blank\">3500 TPS</a>, falling significantly short of our target of <a href=\"https://medium.com/aptoslabs/the-evolution-of-state-sync-the-path-to-100k-transactions-per-second-with-sub-second-latency-at-52e25a2c6f10\" target=\"_blank\">achieving 100k+ TPS</a>.</p><p>A recent breakthrough, however, stemmed from the realization that data dissemination is the primary bottleneck in leader-based protocols, and it can benefit from parallelization. The <a href=\"https://arxiv.org/pdf/2105.11827.pdf\" target=\"_blank\">Narwhal</a> system separated data dissemination from the core consensus logic and proposed an architecture where all validators simultaneously disseminate data, while the consensus component orders only a smaller amount of metadata. The Narwhal paper reported a throughput of 160,000 TPS.</p><p>In a previous post, we presented <a href=\"https://medium.com/aptoslabs/quorum-store-how-consensus-horizontally-scales-on-the-aptos-blockchain-988866f6d5b0\" target=\"_blank\">Quorum Store</a>, our Narwhal implementation to decouple data dissemination from consensus, and how we use it to scale our current consensus protocol, <a href=\"https://arxiv.org/pdf/2106.10362.pdf\" target=\"_blank\">Jolteon</a>. Jolteon is a leader-based protocol that combines the linear fast path of Tendermint with a PBFT style view-change, to reduce the Hotstuff latency by 33%. Nevertheless, it has become apparent that leader-based consensus protocols cannot fully harness Narwhal’s throughput potential. Despite separating data dissemination from consensus, the leaders in Hotstuff/Jolteon are still constrained as throughput increases.</p><p>We, therefore, decided to deploy <a href=\"https://arxiv.org/pdf/2209.05633.pdf\" target=\"_blank\">Bullshark</a>, a zero communication overhead consensus protocol, on top of the Narwhal DAG. Unfortunately, the DAG construction that enables Bullshark’s high throughput comes with a 50% latency price compared to Jolteon.</p><p>In this post, we present Shoal and explain how we drastically reduce Bullshark latency.</p><h3>DAG-BFT Background</h3><p>Let us start with the relevant background for understanding this post. Please refer to the <a href=\"https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/\" target=\"_blank\">DAG meets BFT</a> post for a detailed description of Narwhal and Bullshark.</p><p>Each vertex within the Narwhal DAG is associated with a round number. In order to progress to round <em>r</em>, a validator must first obtain <em>n-f</em> vertices belonging to round <em>r-1</em>. Every validator can broadcast one vertex per round, with each vertex referencing a minimum of <em>n-f</em> vertices from the previous round. Due to the network asynchrony, different validators may observe different local views of the DAG at any point in time. Below is an illustration of a possible local view:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/lp3httkbdw6d.png'/<figcaption><strong>Figure 1. The causal history of the vertex identified by validator 2 in round 2 is highlighted in green.</strong></figcaption></figure><p>A key property of the DAG is non-equivocation: if two validators have the same vertex <em>v</em> in their local view of the DAG, then they have exactly the same causal histories of <em>v</em>.</p><h3>Total Order</h3><p>It is possible to agree on the total order of all vertices in the DAG with no additional communication overhead. In order to do so, validators, in <a href=\"https://arxiv.org/pdf/2102.08325.pdf\" target=\"_blank\">DAG-Rider,</a> <a href=\"https://dl.acm.org/doi/abs/10.1145/3492321.3519594?casa_token=GQtprhA8Ko0AAAAA:P_FcreghKROwtXI6OQUL437Ix1ilommzaMDz3_8sDpfZXYg1m2NZIkRtcJSzGXurgVisqRSVvn6XHw\" target=\"_blank\">Tusk</a>, and Bullshark, interpret the structure of the DAG as a consensus protocol, where a vertex represents a proposal and an edge represents a vote.</p><p>While the quorum intersection logic on the DAG structure differs, all existing Narwhal-based consensus protocols share the following structure:</p><ol><li><strong>Predetermined anchors.</strong> Every few rounds (e.g., two in Bullshark) there is a round with a pre-determined leader. The vertex of the leader is called an anchor.</li><li><strong>Ordering anchors.</strong> Validators independently, but deterministically, decide which anchors to order and which to skip.</li><li><strong>Order causal histories</strong>. Validators process their list of ordered anchors one by one, and for each anchor, order all previously unordered vertices in their causal history by some deterministic rule.</li></ol><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/krx9ttkbdwd1.png'/<figcaption><strong>Figure 2. An illustration of a possible local view of the DAG in Bullshark protocol. In this example, the red and yellow anchors are ordered, while the green (not in the DAG) is skipped. As a result, to order the DAG, the validator deterministically orders the red anchor’s causal history first, and immediately after the yellow’s.</strong></figcaption></figure><p>The key to satisfying safety is to ensure that in step (2) above, all honest validators create a list of ordered anchors such that all lists share the same prefix. In Shoal, we make the following observation regarding all the above protocols:</p><p><strong><em>All validators agree on the first ordered anchor.</em></strong></p><h3>Bullshark Latency</h3><p>Bullshark’s latency depends on the number of rounds between the ordered anchors in the DAG. While the most practical <a href=\"https://arxiv.org/pdf/2209.05633.pdf\" target=\"_blank\">partially synchronous version of Bullshark</a> has better latency than the asynchronous version, it is far from optimal.</p><p><strong>Problem 1: Average block latency.</strong> In Bullshark, there is an anchor in every even round, and vertices in every odd round are interpreted as votes. In the common case, two DAG rounds are required to order an anchor. However, the vertices in the anchor’s causal history require more rounds to wait for the anchor to be ordered. In the common case, vertices in odd rounds require three rounds, while non-anchor vertices in even rounds require four rounds (see Figure 3).</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/cw86ttkbdwp2.png'/<figcaption><strong>Figure 3. In the common case, the anchor in round <em>i+1</em> requires two rounds to be ordered. The vertices in round <em>i</em> are ordered at the same time, therefore their latency is three rounds. The vertices in round <em>i+1</em>, however, must wait for the next anchor to be ordered (the one in round <em>i+3</em>) and thus their order latency is four rounds.</strong></figcaption></figure><p><strong>Problem 2: Failure-Case latency.</strong> The above latency analysis applies to the failure-free case. On the other hand, if a leader of a round fails to broadcast the anchor fast enough, then the anchor cannot be ordered (and is therefore skipped), thus all the unordered vertices in previous rounds must wait for the next anchor to be ordered. This can significantly degrade performance in geo-replicated networks, especially because Bullshark uses timeouts to wait for leaders.</p><h3>Shoal Framework</h3><p>Shoal solves both latency issues. It enhances Bullshark (or any other Narwhal-based BFT protocol) with pipelining, which allows an anchor in every round and reduces the latency for all non-anchor vertices in the DAG to three rounds. Shoal also introduces a zero overhead leader reputation mechanism into the DAG, which biases the selection towards fast leaders.</p><h3>Challenges</h3><p>Pipelining and leader reputation in the context of DAG protocols were considered hard problems for the following reasons:</p><ul><li>Previous pipelining attempts tried to modify the core Bullshark logic, but this inherently seems impossible.</li><li>Introduced in <a href=\"https://developers.diem.com/papers/diem-consensus-state-machine-replication-in-the-diem-blockchain/2021-08-17.pdf\" target=\"_blank\">DiemBFT</a> and formalized in <a href=\"https://arxiv.org/pdf/2110.00960.pdf\" target=\"_blank\">Carousel</a>, Leader Reputation is the idea of dynamically selecting future leaders (anchors in Bullshark) based on validators’ past performance. While disagreeing on leaders’ identities does not violate safety in those protocols, in Bullshark, however, it can lead to completely different orderings. This leads to the core of the problem that selecting round anchors dynamically and deterministically is necessary to solve consensus, while validators need to agree on the ordered history to select future anchors.</li></ul><p>As evidence of the problems’ difficulty, we note that none of the Bullshark implementations, including the ones currently in production in the wild, support these features.</p><h3>Protocol</h3><p>Despite the challenges above, it turns out the solution was hidden behind simplicity, as the saying goes.</p><p>In Shoal, we lean into the power of performing local computations on the DAG and realize the ability to preserve and re-interpret information from previous rounds. With the core insight that all validators agree on the first ordered anchor, Shoal sequentially combines several instances of Bullshark pipelining them such that (1) the first ordered anchor is the switching point for the instances and (2) the anchor’s causal history is used for computing leaders’ reputations.</p><h3>Pipelining</h3><p>Similar to Bullshark, validators apriori agree on potential anchors i.e., there is a known mapping F: R -> V that maps rounds to leaders. Shoal runs instances of Bullshark one after another such that for each instance, the anchors are predetermined by the mapping F. Each instance orders one anchor, which triggers a switch to the next instance.</p><p>Initially, Shoal starts the first instance of Bullshark in the first round of the DAG and runs it until the first ordered anchor is determined, say in round <em>r</em>. All validators agree on this anchor. Therefore, all validators can deterministically agree to reinterpret the DAG starting from round <em>r+1</em>. Shoal simply starts a new instance of Bullshark in round <em>r+1</em>.</p><p>In the best case, this allows Shoal to order an anchor in every round. The anchor in the first round is ordered by the first instance. Then, Shoal starts a new instance in the second round, which itself has an anchor. This anchor is ordered by that instance. Then, another new instance orders an anchor in the third round and the process continues. See the figure below for an illustration:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/lljpttkbdw20.png'/<figcaption><strong>Figure 4. The vertices corresponding to the leaders determined by F are marked by a crown. The first instance of Bullshark starts by interpreting the DAG with anchors in rounds 1, 3, and 5. Bullshark determines that the anchor in round 1, marked by a green checkmark, is the first to be ordered in the first instance. (Note that in the general case, this anchor could be skipped and some other anchor would be the first to be ordered.) Then, the rest of the first instance is ignored and a new instance of Bullshark starts at round 2 with the anchors marked in rounds 2 and 4.</strong></figcaption></figure><h3>Leader reputation</h3><p>Latency increases when anchors are skipped during the Bullshark ordering. In such cases, the pipelining technique cannot help since a new instance cannot be started until the previous instance orders an anchor. Shoal deals with missed anchors by ensuring that the corresponding leaders are less likely to be selected in the future using a reputation mechanism to assign each validator a score based on the history of its recent activity. A validator that has been responsive and participating in the protocol would be assigned a high score. Otherwise, the validator would be assigned a low score since it may be crashed, slow, or malicious.</p><p>The idea is to deterministically re-compute the pre-defined mapping F from rounds to leaders every time the scores are updated, biasing towards leaders with higher scores. In order for validators to agree on the new mapping, they should agree on the scores, and thus on the history used to derive the scores.</p><p>In Shoal, pipelining and leader reputation can be naturally combined as they both utilize the same core technique of re-interpreting the DAG after agreeing on the first ordered anchor.</p><p>In fact, the only difference is that after ordering an anchor in round <em>r</em>, validators just have to compute a new mapping F’, starting from round r+1, based on the causal history of the ordered anchor in round <em>r</em>. Then, the validators start executing a new instance of Bullshark from round <em>r+1</em> with the updated anchor selection function F’. See the illustration below:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/zksrttkbdwrs.png'/<figcaption><strong>Figure 5. The vertices corresponding to the leaders determined by F are marked by a transparent crown. The first instance of Bullshark orders an anchor in round 1, marked by a green checkmark. Then, a new mapping F’ is computed according to the information in the anchor’s causal history. The leaders determined by F’ are marked by a colorful crown.</strong></figcaption></figure><h3>No More Timeouts!</h3><p>Timeouts play a crucial role in all leader-based deterministic partially synchronous BFT implementations. However, they introduce intricacies that increase the number of internal states to manage and observe. This added complexity complicates the debugging process and necessitates more involved observability techniques.</p><p>Timeouts also significantly increase latency since configuring them aptly is non-trivial and often needs to be dynamically adjusted as it is highly environment (network) dependent. The protocol pays a full timeout latency penalty for a faulty leader before it can move on to the next leader. Therefore, timeouts cannot be set too conservatively. But if the timeouts are too short, the protocol may skip good leaders. For example, we observed that with a high load, the leaders in Jolteon/Hotstuff are overwhelmed and timeouts expire before they can drive progress.</p><p>Unfortunately, leader-based protocols (like Hotstuff and Jolteon) inherently require timeouts to ensure protocol progress every time a leader is faulty. Without timeouts, even a crashed leader could stall the protocol forever. Since it is impossible to distinguish between a faulty and a slow leader during asynchronous periods, timeouts may cause validators to view-change all leaders without consensus liveness.</p><p>In Bullshark, timeouts are used in the DAG construction to ensure that in synchronous periods honest leaders add the anchors to the DAG fast enough for them to be ordered.</p><p>We observe that the DAG construction provides a “clock” that estimates the network speed. Without timeouts, the rounds keep advancing as long as <em>n-f</em> honest validators continue adding vertices to the DAG. While Bullshark might not order at network speed (due to faulty leaders), the DAG still grows at network speed despite some leaders being faulty or the network being asynchronous. Eventually, when a non-faulty leader is fast enough to broadcast the anchor, the entire causal history of the anchor will be ordered.</p><p>In our evaluation, we compare Bullshark with and without timeouts across the following cases:</p><ul><li>Fast leader, meaning faster than at least <em>f</em> other validators. In this case, both approaches provide the same latency as anchors are ordered and timeouts are not used.</li><li>Faulty leader. In this case, Bullshark with no timeouts provides much better latency as validators will skip its anchor immediately, whereas with timeouts validators will wait for their expiration before moving on.</li><li>Slow leader. This is the only case where Bullshark with timeouts will perform better. This is because, without timeouts, the anchor will likely be skipped as the leader will fail to broadcast it fast enough, whereas, with timeouts, validators will wait for the anchor.</li></ul><p>In Shoal, avoiding timeouts and leader reputation go hand in hand. Instead of repeatedly waiting for the slow leaders and as a result increasing latency, the leader reputation mechanism excludes slow validators from being selected as leaders. This way, the system takes advantage of the fast validators to operate at network speed in all real-world scenarios.</p><p>Note that the <a href=\"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf\" target=\"_blank\">FLP</a> impossibility result states that no deterministic consensus protocol can avoid timeouts. Shoal does not circumvent this result since there exists a theoretical adversarial schedule of events that can prevent all anchors from being ordered. Instead, Shoal falls back to timeouts after a configurable amount of consecutive skipped anchors. In practice, such a scenario is extremely unlikely.</p><h3>Prevalent Responsiveness</h3><p>The Hotstuff paper popularized the notion of optimistic responsiveness. Although not formally defined, intuitively it means that the protocol can operate at network speed in a good case that includes fast leaders and synchronous networks.</p><p>Shoal provides a strictly better property, which we call <em>prevalent responsiveness</em>. Specifically, compared to Hotstuff, Shoal continues to operate at network speed even if leaders fail for a configurable number of consecutive rounds or the network experiences asynchronous periods. See a more detailed comparison in the table below.</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/3 ";
        final List<String> strings = splitText2Parts(text, 4000, 200);
        for (String str : strings
        ) {
            System.out.println("-------------------------------------------------------------------------------------------");
            System.out.println(str);
            System.out.println("-------------------------------------------------------------------------------------------");

        }
    }
/*    public static void main(String[] args) {
        String str = "<p>By <a href=\"https://twitter.com/ibalajiarun\" target=\"_blank\">Balaji Arun</a> and <a href=\"https://twitter.com/SashaSpiegelman\" target=\"_blank\">Alexander Spiegelman</a></p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/cl0dttkbdwza.png'/</figure><p>World-class engineering meets cutting-edge research at Aptos. For more details, please refer to the <a href=\"https://arxiv.org/pdf/2306.03058.pdf\" target=\"_blank\">Shoal paper</a><strong>.</strong></p><p><strong>TL;DR: We have solved two important open problems in DAG BFT that significantly reduce latency and, for the first time, have eliminated the need for timeouts in deterministic practical protocols. Overall, we have improved Bullshark’s latency by 40% in the failure-free case and by 80% in the failure case.</strong></p><p>Shoal is a framework for enhancing any Narwhal-based consensus protocol (e.g., DAG-Rider, Tusk, Bullshark) with pipelining and leader reputation. Pipelining reduces DAG ordering latency by introducing an anchor every round and, leader reputation further improves it by ensuring anchors are associated with the fastest validators. Moreover, leader reputation allows Shoal to take advantage of the asynchronous DAG construction to eliminate timeouts in all (but extremely uncommon) scenarios. This allows Shoal to provide a property we name Prevalent Responsiveness, which subsumes the often desired Optimistic Responsiveness.</p><p>Our technique, which is surprisingly simple, involves running multiple instances of the underlying protocol one after another sequentially. Consequently, when instantiated with Bullshark, we obtain a Shoal of sharks running a relay race.</p><h3>Motivation</h3><p>In the pursuit of high performance in blockchain networks, there has been a focus on reducing communication complexity. However, this approach has not led to significant improvements in throughput. For instance, Hotstuff — implemented in earlier versions of Diem — achieves only <a href=\"https://arxiv.org/pdf/2103.04234.pdf\" target=\"_blank\">3500 TPS</a>, falling significantly short of our target of <a href=\"https://medium.com/aptoslabs/the-evolution-of-state-sync-the-path-to-100k-transactions-per-second-with-sub-second-latency-at-52e25a2c6f10\" target=\"_blank\">achieving 100k+ TPS</a>.</p><p>A recent breakthrough, however, stemmed from the realization that data dissemination is the primary bottleneck in leader-based protocols, and it can benefit from parallelization. The <a href=\"https://arxiv.org/pdf/2105.11827.pdf\" target=\"_blank\">Narwhal</a> system separated data dissemination from the core consensus logic and proposed an architecture where all validators simultaneously disseminate data, while the consensus component orders only a smaller amount of metadata. The Narwhal paper reported a throughput of 160,000 TPS.</p><p>In a previous post, we presented <a href=\"https://medium.com/aptoslabs/quorum-store-how-consensus-horizontally-scales-on-the-aptos-blockchain-988866f6d5b0\" target=\"_blank\">Quorum Store</a>, our Narwhal implementation to decouple data dissemination from consensus, and how we use it to scale our current consensus protocol, <a href=\"https://arxiv.org/pdf/2106.10362.pdf\" target=\"_blank\">Jolteon</a>. Jolteon is a leader-based protocol that combines the linear fast path of Tendermint with a PBFT style view-change, to reduce the Hotstuff latency by 33%. Nevertheless, it has become apparent that leader-based consensus protocols cannot fully harness Narwhal’s throughput potential. Despite separating data dissemination from consensus, the leaders in Hotstuff/Jolteon are still constrained as throughput increases.</p><p>We, therefore, decided to deploy <a href=\"https://arxiv.org/pdf/2209.05633.pdf\" target=\"_blank\">Bullshark</a>, a zero communication overhead consensus protocol, on top of the Narwhal DAG. Unfortunately, the DAG construction that enables Bullshark’s high throughput comes with a 50% latency price compared to Jolteon.</p><p>In this post, we present Shoal and explain how we drastically reduce Bullshark latency.</p><h3>DAG-BFT Background</h3><p>Let us start with the relevant background for understanding this post. Please refer to the <a href=\"https://decentralizedthoughts.github.io/2022-06-28-DAG-meets-BFT/\" target=\"_blank\">DAG meets BFT</a> post for a detailed description of Narwhal and Bullshark.</p><p>Each vertex within the Narwhal DAG is associated with a round number. In order to progress to round <em>r</em>, a validator must first obtain <em>n-f</em> vertices belonging to round <em>r-1</em>. Every validator can broadcast one vertex per round, with each vertex referencing a minimum of <em>n-f</em> vertices from the previous round. Due to the network asynchrony, different validators may observe different local views of the DAG at any point in time. Below is an illustration of a possible local view:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/lp3httkbdw6d.png'/<figcaption><strong>Figure 1. The causal history of the vertex identified by validator 2 in round 2 is highlighted in green.</strong></figcaption></figure><p>A key property of the DAG is non-equivocation: if two validators have the same vertex <em>v</em> in their local view of the DAG, then they have exactly the same causal histories of <em>v</em>.</p><h3>Total Order</h3><p>It is possible to agree on the total order of all vertices in the DAG with no additional communication overhead. In order to do so, validators, in <a href=\"https://arxiv.org/pdf/2102.08325.pdf\" target=\"_blank\">DAG-Rider,</a> <a href=\"https://dl.acm.org/doi/abs/10.1145/3492321.3519594?casa_token=GQtprhA8Ko0AAAAA:P_FcreghKROwtXI6OQUL437Ix1ilommzaMDz3_8sDpfZXYg1m2NZIkRtcJSzGXurgVisqRSVvn6XHw\" target=\"_blank\">Tusk</a>, and Bullshark, interpret the structure of the DAG as a consensus protocol, where a vertex represents a proposal and an edge represents a vote.</p><p>While the quorum intersection logic on the DAG structure differs, all existing Narwhal-based consensus protocols share the following structure:</p><ol><li><strong>Predetermined anchors.</strong> Every few rounds (e.g., two in Bullshark) there is a round with a pre-determined leader. The vertex of the leader is called an anchor.</li><li><strong>Ordering anchors.</strong> Validators independently, but deterministically, decide which anchors to order and which to skip.</li><li><strong>Order causal histories</strong>. Validators process their list of ordered anchors one by one, and for each anchor, order all previously unordered vertices in their causal history by some deterministic rule.</li></ol><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/krx9ttkbdwd1.png'/<figcaption><strong>Figure 2. An illustration of a possible local view of the DAG in Bullshark protocol. In this example, the red and yellow anchors are ordered, while the green (not in the DAG) is skipped. As a result, to order the DAG, the validator deterministically orders the red anchor’s causal history first, and immediately after the yellow’s.</strong></figcaption></figure><p>The key to satisfying safety is to ensure that in step (2) above, all honest validators create a list of ordered anchors such that all lists share the same prefix. In Shoal, we make the following observation regarding all the above protocols:</p><p><strong><em>All validators agree on the first ordered anchor.</em></strong></p><h3>Bullshark Latency</h3><p>Bullshark’s latency depends on the number of rounds between the ordered anchors in the DAG. While the most practical <a href=\"https://arxiv.org/pdf/2209.05633.pdf\" target=\"_blank\">partially synchronous version of Bullshark</a> has better latency than the asynchronous version, it is far from optimal.</p><p><strong>Problem 1: Average block latency.</strong> In Bullshark, there is an anchor in every even round, and vertices in every odd round are interpreted as votes. In the common case, two DAG rounds are required to order an anchor. However, the vertices in the anchor’s causal history require more rounds to wait for the anchor to be ordered. In the common case, vertices in odd rounds require three rounds, while non-anchor vertices in even rounds require four rounds (see Figure 3).</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/cw86ttkbdwp2.png'/<figcaption><strong>Figure 3. In the common case, the anchor in round <em>i+1</em> requires two rounds to be ordered. The vertices in round <em>i</em> are ordered at the same time, therefore their latency is three rounds. The vertices in round <em>i+1</em>, however, must wait for the next anchor to be ordered (the one in round <em>i+3</em>) and thus their order latency is four rounds.</strong></figcaption></figure><p><strong>Problem 2: Failure-Case latency.</strong> The above latency analysis applies to the failure-free case. On the other hand, if a leader of a round fails to broadcast the anchor fast enough, then the anchor cannot be ordered (and is therefore skipped), thus all the unordered vertices in previous rounds must wait for the next anchor to be ordered. This can significantly degrade performance in geo-replicated networks, especially because Bullshark uses timeouts to wait for leaders.</p><h3>Shoal Framework</h3><p>Shoal solves both latency issues. It enhances Bullshark (or any other Narwhal-based BFT protocol) with pipelining, which allows an anchor in every round and reduces the latency for all non-anchor vertices in the DAG to three rounds. Shoal also introduces a zero overhead leader reputation mechanism into the DAG, which biases the selection towards fast leaders.</p><h3>Challenges</h3><p>Pipelining and leader reputation in the context of DAG protocols were considered hard problems for the following reasons:</p><ul><li>Previous pipelining attempts tried to modify the core Bullshark logic, but this inherently seems impossible.</li><li>Introduced in <a href=\"https://developers.diem.com/papers/diem-consensus-state-machine-replication-in-the-diem-blockchain/2021-08-17.pdf\" target=\"_blank\">DiemBFT</a> and formalized in <a href=\"https://arxiv.org/pdf/2110.00960.pdf\" target=\"_blank\">Carousel</a>, Leader Reputation is the idea of dynamically selecting future leaders (anchors in Bullshark) based on validators’ past performance. While disagreeing on leaders’ identities does not violate safety in those protocols, in Bullshark, however, it can lead to completely different orderings. This leads to the core of the problem that selecting round anchors dynamically and deterministically is necessary to solve consensus, while validators need to agree on the ordered history to select future anchors.</li></ul><p>As evidence of the problems’ difficulty, we note that none of the Bullshark implementations, including the ones currently in production in the wild, support these features.</p><h3>Protocol</h3><p>Despite the challenges above, it turns out the solution was hidden behind simplicity, as the saying goes.</p><p>In Shoal, we lean into the power of performing local computations on the DAG and realize the ability to preserve and re-interpret information from previous rounds. With the core insight that all validators agree on the first ordered anchor, Shoal sequentially combines several instances of Bullshark pipelining them such that (1) the first ordered anchor is the switching point for the instances and (2) the anchor’s causal history is used for computing leaders’ reputations.</p><h3>Pipelining</h3><p>Similar to Bullshark, validators apriori agree on potential anchors i.e., there is a known mapping F: R -> V that maps rounds to leaders. Shoal runs instances of Bullshark one after another such that for each instance, the anchors are predetermined by the mapping F. Each instance orders one anchor, which triggers a switch to the next instance.</p><p>Initially, Shoal starts the first instance of Bullshark in the first round of the DAG and runs it until the first ordered anchor is determined, say in round <em>r</em>. All validators agree on this anchor. Therefore, all validators can deterministically agree to reinterpret the DAG starting from round <em>r+1</em>. Shoal simply starts a new instance of Bullshark in round <em>r+1</em>.</p><p>In the best case, this allows Shoal to order an anchor in every round. The anchor in the first round is ordered by the first instance. Then, Shoal starts a new instance in the second round, which itself has an anchor. This anchor is ordered by that instance. Then, another new instance orders an anchor in the third round and the process continues. See the figure below for an illustration:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/lljpttkbdw20.png'/<figcaption><strong>Figure 4. The vertices corresponding to the leaders determined by F are marked by a crown. The first instance of Bullshark starts by interpreting the DAG with anchors in rounds 1, 3, and 5. Bullshark determines that the anchor in round 1, marked by a green checkmark, is the first to be ordered in the first instance. (Note that in the general case, this anchor could be skipped and some other anchor would be the first to be ordered.) Then, the rest of the first instance is ignored and a new instance of Bullshark starts at round 2 with the anchors marked in rounds 2 and 4.</strong></figcaption></figure><h3>Leader reputation</h3><p>Latency increases when anchors are skipped during the Bullshark ordering. In such cases, the pipelining technique cannot help since a new instance cannot be started until the previous instance orders an anchor. Shoal deals with missed anchors by ensuring that the corresponding leaders are less likely to be selected in the future using a reputation mechanism to assign each validator a score based on the history of its recent activity. A validator that has been responsive and participating in the protocol would be assigned a high score. Otherwise, the validator would be assigned a low score since it may be crashed, slow, or malicious.</p><p>The idea is to deterministically re-compute the pre-defined mapping F from rounds to leaders every time the scores are updated, biasing towards leaders with higher scores. In order for validators to agree on the new mapping, they should agree on the scores, and thus on the history used to derive the scores.</p><p>In Shoal, pipelining and leader reputation can be naturally combined as they both utilize the same core technique of re-interpreting the DAG after agreeing on the first ordered anchor.</p><p>In fact, the only difference is that after ordering an anchor in round <em>r</em>, validators just have to compute a new mapping F’, starting from round r+1, based on the causal history of the ordered anchor in round <em>r</em>. Then, the validators start executing a new instance of Bullshark from round <em>r+1</em> with the updated anchor selection function F’. See the illustration below:</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/31/zksrttkbdwrs.png'/<figcaption><strong>Figure 5. The vertices corresponding to the leaders determined by F are marked by a transparent crown. The first instance of Bullshark orders an anchor in round 1, marked by a green checkmark. Then, a new mapping F’ is computed according to the information in the anchor’s causal history. The leaders determined by F’ are marked by a colorful crown.</strong></figcaption></figure><h3>No More Timeouts!</h3><p>Timeouts play a crucial role in all leader-based deterministic partially synchronous BFT implementations. However, they introduce intricacies that increase the number of internal states to manage and observe. This added complexity complicates the debugging process and necessitates more involved observability techniques.</p><p>Timeouts also significantly increase latency since configuring them aptly is non-trivial and often needs to be dynamically adjusted as it is highly environment (network) dependent. The protocol pays a full timeout latency penalty for a faulty leader before it can move on to the next leader. Therefore, timeouts cannot be set too conservatively. But if the timeouts are too short, the protocol may skip good leaders. For example, we observed that with a high load, the leaders in Jolteon/Hotstuff are overwhelmed and timeouts expire before they can drive progress.</p><p>Unfortunately, leader-based protocols (like Hotstuff and Jolteon) inherently require timeouts to ensure protocol progress every time a leader is faulty. Without timeouts, even a crashed leader could stall the protocol forever. Since it is impossible to distinguish between a faulty and a slow leader during asynchronous periods, timeouts may cause validators to view-change all leaders without consensus liveness.</p><p>In Bullshark, timeouts are used in the DAG construction to ensure that in synchronous periods honest leaders add the anchors to the DAG fast enough for them to be ordered.</p><p>We observe that the DAG construction provides a “clock” that estimates the network speed. Without timeouts, the rounds keep advancing as long as <em>n-f</em> honest validators continue adding vertices to the DAG. While Bullshark might not order at network speed (due to faulty leaders), the DAG still grows at network speed despite some leaders being faulty or the network being asynchronous. Eventually, when a non-faulty leader is fast enough to broadcast the anchor, the entire causal history of the anchor will be ordered.</p><p>In our evaluation, we compare Bullshark with and without timeouts across the following cases:</p><ul><li>Fast leader, meaning faster than at least <em>f</em> other validators. In this case, both approaches provide the same latency as anchors are ordered and timeouts are not used.</li><li>Faulty leader. In this case, Bullshark with no timeouts provides much better latency as validators will skip its anchor immediately, whereas with timeouts validators will wait for their expiration before moving on.</li><li>Slow leader. This is the only case where Bullshark with timeouts will perform better. This is because, without timeouts, the anchor will likely be skipped as the leader will fail to broadcast it fast enough, whereas, with timeouts, validators will wait for the anchor.</li></ul><p>In Shoal, avoiding timeouts and leader reputation go hand in hand. Instead of repeatedly waiting for the slow leaders and as a result increasing latency, the leader reputation mechanism excludes slow validators from being selected as leaders. This way, the system takes advantage of the fast validators to operate at network speed in all real-world scenarios.</p><p>Note that the <a href=\"https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf\" target=\"_blank\">FLP</a> impossibility result states that no deterministic consensus protocol can avoid timeouts. Shoal does not circumvent this result since there exists a theoretical adversarial schedule of events that can prevent all anchors from being ordered. Instead, Shoal falls back to timeouts after a configurable amount of consecutive skipped anchors. In practice, such a scenario is extremely unlikely.</p><h3>Prevalent Responsiveness</h3><p>The Hotstuff paper popularized the notion of optimistic responsiveness. Although not formally defined, intuitively it means that the protocol can operate at network speed in a good case that includes fast leaders and synchronous networks.</p><p>Shoal provides a strictly better property, which we call <em>prevalent responsiveness</em>. Specifically, compared to Hotstuff, Shoal continues to operate at network speed even if leaders fail for a configurable number of consecutive rounds or the network experiences asynchronous periods. See a more detailed comparison in the table below.</p><figure><img src='https://sosponge.s3.ap-southeast-1.amazonaws.com/sosponge/web3image/23/10/3";
        final List<String> strings = splitIntoThreeParts(str);
        for (String content : strings) {
            System.out.println("------>size:{}" + content.length());
            System.out.println("------>content:{}" + content);
        }
    }*/

    public static List<String> splitContentByMaxLength(String input, int chunkSize) {
        if (input.length() <= chunkSize) {
            return Collections.singletonList(input);
        }
        int length = input.length();
        int numOfChunks = (int) Math.ceil((double) length / chunkSize);
        List<String> list = new ArrayList<>(numOfChunks);
        for (int i = 0; i < numOfChunks; i++) {
            int startIndex = i * chunkSize;
            int endIndex = Math.min(startIndex + chunkSize, length);
            list.add(input.substring(startIndex, endIndex));
        }
        return list;
    }
}
